#include <HAL/Gamepad.pb.h>
#include <HAL/Gamepad/GamepadDevice.h>
#include <HAL/Car.pb.h>
#include <HAL/Car/CarDevice.h>
#include <thread>
//#include <signal.h>
#include <spirit/spirit.h>
#include <HAL/Posys/PosysDevice.h>
#include <iostream>
#include <fstream>
#include <cmath>


//hal::CarCommandMsg commandMSG;

//void GamepadCallback(hal::GamepadMsg& _msg) {
//  commandMSG.set_steering_angle(_msg.axes().data(0));
//  commandMSG.set_throttle_percent(_msg.axes().data(5)*20);
//}

int main(int argc, char** argv) {
  // connect to a gamepad
//  hal::Gamepad gamepad("gamepad:/");
//  gamepad.RegisterGamepadDataCallback(&GamepadCallback);

  // Initialize commands
//  commandMSG.set_steering_angle(0);
//  commandMSG.set_throttle_percent(0);

  // Create world setting object
  spSettings settings_obj;
  settings_obj.SetGuiType(spGuiType::GUI_PANGOSCENEGRAPH);
  settings_obj.SetPhysicsEngineType(spPhyEngineType::PHY_BULLET);

  // create the world object
  spirit spworld(settings_obj);

  // create a car with default values at car_param object
  spObjectHandle car_handle = spworld.objects_.CreateVehicle(spworld.car_param);
  spworld.gui_.AddObject(spworld.objects_.GetObject(car_handle));
  spAWSDCar& car = (spAWSDCar&) spworld.objects_.GetObject(car_handle);

  // create a flat ground with a box object
  spPose gnd_pose_ = spPose::Identity();
  gnd_pose_.translate(spTranslation(0,0,-0.5));
  spObjectHandle gnd_handle = spworld.objects_.CreateBox(gnd_pose_,spBoxSize(50,50,1),0,spColor(0,1,0));
  spworld.gui_.AddObject(spworld.objects_.GetObject(gnd_handle));

  // set friction coefficent of ground
  ((spBox&)spworld.objects_.GetObject(gnd_handle)).SetFriction(1);


  float x0 = 1;
  float y0 = -5;
  float yaw0 = 0;
  float v0 = 10;
  float thrust_u = 20; // range: -50, 50
  float turn_u = SP_PI_QUART; // range: -pi/4, pi/4
  std::ifstream in_file;
  in_file.open ("temp_files/sim_input.txt");
  in_file >> yaw0 >> x0 >> y0 >> v0 >> thrust_u >> turn_u;
  in_file.close();

  float v0_x = -v0*sin(yaw0);
  float v0_y = v0*cos(yaw0);

  std::cout << yaw0 << ", " << x0 << ", " << y0 << ", " << v0_x << ", " << v0_y << ", " << thrust_u << ", " << turn_u << std::endl;
  
  spState initState;
  initState.pose = spPose::Identity();
  initState.pose.translate(spTranslation(x0,y0,0.06));
  Eigen::AngleAxisd initRot(yaw0,Eigen::Vector3d::UnitZ());
  initState.pose.rotate(initRot);
  initState.linvel = spVector3(v0_x, v0_y, 0);

  car.SetState(initState);

  int i = 0;
  while(i < 100) {
//    car.SetEngineMaxVel(commandMSG.throttle_percent());
//    car.SetFrontSteeringAngle(commandMSG.steering_angle());

    // set some constant values for engine velocity and front steering angle
    // Input
    
    Eigen::Matrix3d rotmat = car.GetPose().rotation();
    float x = car.GetState().pose.translation()[0];
    float y = car.GetState().pose.translation()[1];
    float yaw = std::atan2(rotmat(1,0),rotmat(0,0));
    float v = car.GetState().linvel.norm();

    // float settle_time = 0.1;
    // float dest_vel = 22.0*(thrust_u*settle_time+v);
    // car.SetEngineMaxVel(dest_vel);
    car.SetEngineMaxVel(100);
    float torque0 = 0.0002;
    car.SetEngineTorque(thrust_u+torque0);
    car.SetFrontSteeringAngle(turn_u);
    std::cout << yaw << ", " << x << ", " << y << ", " << v << std::endl;
    std::cout << thrust_u << ", " << turn_u << std::endl;

    // step physics simulation for 0.01 seconds
    spworld.objects_.StepPhySimulation(0.01);

    // iterate gui to update object status
    spworld.gui_.Iterate(spworld.objects_);

    // Output
    // float dx = 0;
    // float dy = 0;
    // float dyaw = 0;
    // float dv = 0;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    i++;
  }
  return 0;
}
